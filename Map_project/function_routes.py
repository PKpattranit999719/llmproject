from turtle import st
import streamlit as st
import requests
import urllib.parse
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import JsonOutputParser
from pydantic import BaseModel
import folium
from geopy.distance import geodesic
from IPython.display import display
import streamlit.components.v1 as components 

# Define a model for keyword extraction
class SearchKeyword(BaseModel):
    keyword: str

# Initialize LLM with centralized server configuration
url = 'http://111.223.37.52/v1'
api_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7Im9yZ2FuaXphdGlvbl9pZCI6IjY3NjhkNzA3YjNiYmM5MWQwYWNjMWNjNCIsInRva2VuX25hbWUiOiJCYW5rIiwic3RkRGF0ZSI6IjIwMjUtMDEtMTlUMTc6MDA6MDAuMDAwWiJ9LCJpYXQiOjE3MzczNTkxMDcsImV4cCI6MTc0MDU4OTE5OX0.7peNsGJSnQL2tctiui3MXTBc5OZsLv8OSizh68KVH5w'

llm = ChatOpenAI(
    model="gpt-4o-mini",
    base_url=url,
    api_key=api_key,
    max_tokens=1000
)

def clean_keyword(keyword: str):
    return keyword.strip().lower()

def process_places_of_interest_routes(places_interest):
    try:
        parser = JsonOutputParser(pydantic_object=SearchKeyword)
        format_instructions = """
        ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏£‡∏≠‡∏á‡∏Ñ‡∏≥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ.
        ‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏∑‡∏≠: {places_of_interest}
        ‡∏Ñ‡∏≥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏Ñ‡∏∑‡∏≠‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ‡πÄ‡∏ä‡πà‡∏ô:
        - ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≤‡∏ô‡∏Ç‡πâ‡∏≤‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏ß‡∏∞‡∏û‡∏±‡∏Å‡∏ó‡∏≤‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£: "‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£"
        - ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≤‡∏ô‡∏Å‡∏≤‡πÅ‡∏ü: "‡∏£‡πâ‡∏≤‡∏ô‡∏Å‡∏≤‡πÅ‡∏ü"
        - ‡∏´‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≥: "‡∏´‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≥"
        - ‡∏´‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏¥‡∏°‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô: "‡∏õ‡∏±‡πä‡∏°‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô"
        - ‡∏´‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏ù‡∏≤‡∏Å: "‡∏£‡πâ‡∏≤‡∏ô‡∏Ç‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏ù‡∏≤‡∏Å"
        - ‡∏´‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á: "‡∏£‡πâ‡∏≤‡∏ô‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡∏ã‡∏∑‡πâ‡∏≠"
        - ‡∏´‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ß‡∏∞‡∏û‡∏±‡∏Å‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á: "‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏±‡∏Å"
        ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON ‡∏ï‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ:
        {
            "keyword": "<extracted_keyword>"
        }
        """
        
        prompt = PromptTemplate(
            template="""\
            ## ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏Ñ‡∏≥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ.

            # ‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {places_of_interest}

            # Your response should be structured as follows:
            {format_instructions}
            """,
            input_variables=["places_of_interest"],
            partial_variables={"format_instructions": format_instructions},
        )

        chain = prompt | llm | parser
        event = chain.invoke({"places_of_interest": places_interest})

        # print(f"Raw extracted event: {event}")  # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å chain.invoke
        
        if event:
            keyword = event.get('keyword', '')
            cleaned_keyword = clean_keyword(keyword)
            if cleaned_keyword:
                return cleaned_keyword
    except Exception as e:
        print(f"Error processing user query: {e}")
        return None
    
def convert_locations(user_location, user_destination):
    flat, flon = user_location
    tlat, tlon = user_destination
    return flon, flat, tlon, tlat

def get_route_data(flon, flat, tlon, tlat):
    """
    Get the route data from the Longdo API based on the given start and end points.

    Args:
        flon (float): Longitude of the start point.
        flat (float): Latitude of the start point.
        tlon (float): Longitude of the destination point.
        tlat (float): Latitude of the destination point.

    Returns:
        dict: Route data returned by the Longdo API.
    """
    try:
        base_url = "https://api.longdo.com/RouteService/json/route/guide?"
        params = {
            'key': '7b6f8a4c53a57fa8315fbdcf5b108c83',
            'flon': flon,
            'flat': flat,
            'tlon': tlon,
            'tlat': tlat
        }
        full_url = base_url + urllib.parse.urlencode(params)

        response = requests.get(full_url)
        response.raise_for_status()
        route_data = response.json()
        print(route_data)
    
        print(f"Route data received: {route_data}")  # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å API
    
        return route_data
    except requests.exceptions.RequestException as e:
        print(f"Error fetching route data: {e}")
    return None

def get_lat_lon_from_osm(searched_location):
    """
    Get latitude and longitude from OpenStreetMap Nominatim API.

    Args:
        searched_location (str): The name of the place to search.

    Returns:
        tuple: Latitude and longitude of the searched place, or None if not found.
    """
    url = f'https://nominatim.openstreetmap.org/search?q={urllib.parse.quote(searched_location)}&format=json'
    headers = {'User-Agent': 'MyGeocodingApp/1.0'}
    
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # ‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ HTTP request ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        data = response.json()
        
        if data:
            lat = data[0].get('lat')
            lon = data[0].get('lon')
            return lat, lon
    except requests.exceptions.RequestException as e:
        print(f"Error during geocoding: {e}")
    
    return None, None

def get_places_from_route(route_data):
    """
    Extract place name, latitude, and longitude from route data using OpenStreetMap Nominatim API.
    
    Args:
        route_data (dict): Route data containing the list of guide points.

    Returns:
        list: A list of dictionaries containing place_name, latitude, and longitude.
    """
    places_with_coordinates = []

    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ route_data ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞ 'data' ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if 'data' in route_data and isinstance(route_data['data'], list) and len(route_data['data']) > 0:
        # ‡πÉ‡∏ä‡πâ .get() ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• guide ‡∏à‡∏≤‡∏Å data[0] ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
        guide_points = route_data['data'][0].get('guide', [])
        
        for point in guide_points:
            name = point.get('name')
            
            print(f"Processing point: {name}")  # ‡∏î‡∏π‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏∏‡∏î‡πÑ‡∏´‡∏ô‡∏°‡∏≤‡∏ö‡πâ‡∏≤‡∏á
            
            if name:
                latitude, longitude = get_lat_lon_from_osm(name)
                
                print(f"Resolved coordinates for {name}: lat={latitude}, lon={longitude}")  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å OSM API
                
                if latitude and longitude:
                    places_with_coordinates.append({
                        "place_name": name,
                        "latitude": latitude,
                        "longitude": longitude
                    })
    else:
        print("Route data is empty or has an invalid structure.")
    
    return places_with_coordinates


def search_interest_logdo_map_api(keyword, location, radius):
    try:
        base_url = "https://search.longdo.com/mapsearch/json/search?" 
        params = {
            'key': '7b6f8a4c53a57fa8315fbdcf5b108c83',
            'lon': location[1],
            'lat': location[0],
            'radius': radius * 1000,
            'keyword': keyword
        }
        full_url = base_url + urllib.parse.urlencode(params)

        response = requests.get(full_url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching data from Longdo API: {e}")
    return None

def search_places_of_interest(flon, flat, tlon, tlat, keyword, radius):
    """
    Get route data and search for places of interest along the route.

    Args:
        flon (float): Longitude of the start point.
        flat (float): Latitude of the start point.
        tlon (float): Longitude of the destination point.
        tlat (float): Latitude of the destination point.
        keyword (str): Keyword to search for places of interest.
        radius (int): Radius in kilometers to search for places around each point.

    Returns:
        list: A list containing places of interest along the route.
    """
    route_data = get_route_data(flon, flat, tlon, tlat)
    
    # print(f"Fetched route data: {route_data}")  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å API
    
    if not route_data:
        print("Failed to fetch route data.")
        return []
    
    # Extract coordinates from route_data
    places_with_coordinates = get_places_from_route(route_data)
    
    # Search for places of interest using the extracted coordinates
    places_of_interest = []
       
    for place in places_with_coordinates[:5]:
        latitude = place["latitude"]
        longitude = place["longitude"]
        
        found_places = search_interest_logdo_map_api(keyword, (latitude, longitude), radius)
     
        # print(f"üìç Found places at ({latitude}, {longitude}):", found_places)  # Debug
        places_of_interest.append(found_places)
    
    return places_of_interest

################################ ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Å‡πá‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏´‡∏°‡∏î‡∏ô‡∏∞‡πÑ‡∏î‡πâ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ print ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ñ‡πà‡∏≤‡πÅ‡∏•‡πâ‡∏ß #########################################33
# ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÑ‡∏õ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πà‡πÉ‡∏ô main  ‡πÄ‡∏î‡∏µ‡πã‡∏¢‡∏ß‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏î‡∏µ‡πã‡∏¢‡∏ß‡∏à‡∏∞‡∏•‡∏ö‡∏≠‡∏≠‡∏Å
def sort_points(points, user_location, user_destination):
    """
    Sort points based on distance from the starting point sequentially.

    Args:
        points (list): List of dictionaries containing place_name, latitude, and longitude.
        start (dict or tuple or list): Start point, can be a dict, tuple, or list.
        end (dict or tuple or list): End point, can be a dict, tuple, or list.

    Returns:
        list: List of sorted points (excluding start but including end).
    """

    # # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô dictionary
    # def convert_to_dict(point):
    #     if isinstance(point, dict):
    #         return point  # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô dictionary ‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏õ‡∏•‡∏á
    #     elif isinstance(point, (tuple, list)) and len(point) == 3:
    #         return {"place_name": point[0], "latitude": point[1], "longitude": point[2]}
    #     else:
    #         raise ValueError("Point must be a tuple, list, or dictionary with three elements.")

    # # ‡πÅ‡∏õ‡∏•‡∏á start ‡πÅ‡∏•‡∏∞ end ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà dictionary
    # start = convert_to_dict(start)
    # end = convert_to_dict(end)

    # # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ points ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡πÉ‡∏ô list ‡πÄ‡∏õ‡πá‡∏ô dictionary
    # if not all(isinstance(p, dict) for p in points):
    #     raise ValueError("All points must be dictionaries.")

    # # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÅ‡∏ï‡πà‡∏•‡∏∞ dictionary ‡πÉ‡∏ô points, start, ‡πÅ‡∏•‡∏∞ end ‡∏°‡∏µ key ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    # required_keys = ['place_name', 'latitude', 'longitude']
    # for point in [start, end] + points:
    #     if not all(key in point for key in required_keys):  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÅ‡∏ï‡πà‡∏•‡∏∞ dictionary ‡∏°‡∏µ key ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    #         raise ValueError(f"Each point must contain keys: {required_keys}")

    sorted_points = [user_location]  # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    points = points.copy()  # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏ô‡∏≤‡∏Ç‡∏≠‡∏á list points
    current_point = user_location  # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô

    # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    while points:
        next_point = min(points, key=lambda p: geodesic(
            (current_point["latitude"], current_point["longitude"]),
            (p["latitude"], p["longitude"])
        ).meters)
        
        sorted_points.append(next_point)
        points.remove(next_point)
        current_point = next_point  # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏à‡∏∏‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô

    sorted_points.append(user_destination)  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡∏ï‡∏≠‡∏ô‡∏à‡∏ö
    # print(f"****Sorted points: {[p['place_name'] for p in sorted_points]}")  # Debugging
    return sorted_points[1:]  # ‡∏ï‡∏±‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå


# ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á ‡πÅ‡∏•‡∏∞ ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ô‡πà‡∏≤‡∏™‡∏ô‡πÉ‡∏à
def create_map(route_data, places_of_interest, start_location, end_location, places_with_coordinates):
    """
    Create and display a map with route data and places of interest.

    Args:
        route_data (dict): Route information containing guide points.
        places_of_interest (list): List of places containing additional information.
        start_location (tuple): Starting point (lat, lon).
        end_location (tuple): Ending point (lat, lon).
        places_with_coordinates (list): List of places with coordinates.
    """
    if not route_data:
        print("No route data available.")
        return

    # Create the base map centered between start and end locations
    midpoint = (
        (start_location[0] + end_location[0]) / 2,
        (start_location[1] + end_location[1]) / 2
    )
    m = folium.Map(location=midpoint, zoom_start=12)

    # Add markers for start and end locations
    folium.Marker(
        location=start_location,
        popup="Start Location",
        icon=folium.Icon(color="blue", icon="info-sign")
    ).add_to(m)

    folium.Marker(
        location=end_location,
        popup="End Location",
        icon=folium.Icon(color="red", icon="info-sign")
    ).add_to(m)

    # Add markers for the places in places_with_coordinates
    if places_with_coordinates:
        for idx, point in enumerate(places_with_coordinates):
            folium.Marker(
                location=[point["latitude"], point["longitude"]],
                popup=f"{idx + 1}: {point['place_name']}",
                icon=folium.Icon(color="green", icon="info-sign")
            ).add_to(m)

        # Draw the route line connecting the points (from start to places and to the end)
        route_coords = [[point["latitude"], point["longitude"]] for point in places_with_coordinates]
        folium.PolyLine([start_location] + route_coords + [end_location], color="blue", weight=3, opacity=0.8).add_to(m)

    # Extract places of interest and add them to the map
    places_data = extract_and_return_data_from_places(places_of_interest)

    for data in places_data:
        place_name = data.get('place_name', '')
        place_lat = data.get('place_lat', '')  # Use 'place_lat' as it is stored in extracted data
        place_lon = data.get('place_lon', '')  # Use 'place_lon' as it is stored in extracted data

        # print(f"Adding place: {place_name}, Lat: {place_lat}, Lon: {place_lon}")  # Debugging

        # Check if latitude and longitude are valid before adding marker
        try:
            place_lat = float(place_lat)
            place_lon = float(place_lon)
            folium.Marker(
                location=[place_lat, place_lon],
                popup=f"Place: {place_name}",
                icon=folium.Icon(color='purple', icon='info-sign')
            ).add_to(m)
        except ValueError:
            print(f"Skipping place {place_name} due to invalid coordinates.")

    map_html = m._repr_html_()  # Get the HTML representation of the map
    st.components.v1.html(map_html, height=600)  # Display the map in Streamlit
            # Display the map
    # display(m)

# ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô ‡∏ü‡∏±‡∏á‡∏Ç‡∏±‡πà‡∏ô search_places_of_interest ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏¢‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô
def extract_and_return_data_from_places(places_of_interest):
    """
    Extract and return data from places_of_interest.
    Args:
        places_of_interest (list): List of places containing place_name and data.
    Returns:
        list: A list of dictionaries containing the name, latitude, and longitude of places.
    """
    extracted_data = []
 
    print("--------------------------------------------------------------------------------------")
    for place in places_of_interest:  # ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÉ‡∏ô places_of_interest
        data_list = place.get("data", [])  # ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ data ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ (‡πÄ‡∏õ‡πá‡∏ô list)
        
        for val in data_list:  # ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÉ‡∏ô data ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ lat/lon
            place_name = val.get("name", "Unknown")
            place_lat = val.get("lat", "Unknown")
            place_lon = val.get("lon", "Unknown")
            
            extracted_data.append({
                'place_name': place_name,
                'place_lat': place_lat,
                'place_lon': place_lon,
            })

    # print(extracted_data)  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
    print("--------------------------------------------------------------------------------------")
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏°‡∏µ
        # places_data = place.get('places', {}).get('data', [])
        # if places_data:
        #     for data in places_data:
        #         data_name = data.get('name', 'Unknown')
        #         data_lat = data.get('lat', 'Unknown')
        #         data_lon = data.get('lon', 'Unknown')

        #         # ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏°‡∏≤
        #         extracted_data.append({
        #             'place_name': place_name,
        #             'place_lat': place_lat,
        #             'place_lon': place_lon,
        #             'name': data_name,
        #             'lat': data_lat,
        #             'lon': data_lon
        #         })
        # else:
        #     # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πà‡∏≠‡∏¢‡∏Å‡πá‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å
        #     extracted_data.append({
        #         'place_name': place_name,
        #         'place_lat': place_lat,
        #         'place_lon': place_lon
        #     })

    return extracted_data

# ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà  ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏ô‡∏µ‡πâ
# def extract_and_analyze_data(places_of_interest):
#     """
#     Extract and analyze data from places_of_interest, considering factors like convenience, opening hours, price, and reviews.
#     Args:
#         places_of_interest (list): List of places containing place_name and data.
#     Returns:
#         list: A list of dictionaries containing place analysis including convenience, price, and reviews.
#     """
#     analyzed_data = []

#     if not places_of_interest:
#         print("No places of interest to analyze.")
#         return analyzed_data

#     for place in places_of_interest:
#         place_name = place.get('name', 'Unknown')
#         place_lat = place.get('lat', 'Unknown')
#         place_lon = place.get('lon', 'Unknown')

#         places_data = place.get('places', {}).get('data', [])
#         if places_data:
#             for data in places_data:
#                 data_name = data.get('name', 'Unknown')
#                 data_lat = data.get('lat', 'Unknown')
#                 data_lon = data.get('lon', 'Unknown')
#                 opening_hours = data.get('opening_hours', 'Unknown')
#                 price_range = data.get('price_range', 'Unknown')
#                 reviews = data.get('reviews', [])

#                 # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏à‡∏≤‡∏Å‡∏£‡∏µ‡∏ß‡∏¥‡∏ß
#                 average_review_score = 0
#                 if reviews:
#                     total_score = sum(review.get('score', 0) for review in reviews)
#                     average_review_score = total_score / len(reviews)

#                 # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å
#                 distance = calculate_distance(place_lat, place_lon, data_lat, data_lon)
#                 convenience_score = max(0, 10 - distance)

#                 analyzed_data.append({
#                     'place_name': place_name,
#                     'place_lat': place_lat,
#                     'place_lon': place_lon,
#                     'name': data_name,
#                     'lat': data_lat,
#                     'lon': data_lon,
#                     'opening_hours': opening_hours,
#                     'price_range': price_range,
#                     'average_review_score': average_review_score,
#                     'convenience_score': convenience_score
#                 })
#         else:
#             # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πà‡∏≠‡∏¢ ‡∏Å‡πá‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å
#             analyzed_data.append({
#                 'place_name': place_name,
#                 'place_lat': place_lat,
#                 'place_lon': place_lon
#             })

#     print(analyzed_data)
    
#     return analyzed_data

def calculate_distance(lat1, lon1, lat2, lon2):
    """
    Calculate the distance between two coordinates (in kilometers).
    Args:
        lat1, lon1 (float): Coordinates of the starting point.
        lat2, lon2 (float): Coordinates of the destination point.
    Returns:
        float: The distance between the two points in kilometers.
    """
    return geodesic((lat1, lon1), (lat2, lon2)).kilometers

def recommend_places(places_of_interest, keyword, radius):
    """
    Use LLM to recommend places based on analyzed data.

    Args:
        places_of_interest: The places for after searching.
        keyword (str): The keyword used for searching.
        radius (int): Radius in kilometers to search for places around each point.

    Returns:
        str: LLM response with recommendations.
    """
    if not places_of_interest:
        return "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤."
    
    # Generate the information string for LLM prompt
    places_info = "\n".join([f"{index+1}. {place.get['name']} (‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á: {place.get('distance', 'N/A'):.2f} ‡∏Å‡∏°.) - [‡∏î‡∏π‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°](https://www.wongnai.com/search?query={place['name']})" for index, place in enumerate(places_of_interest)])

    prompt = f"""
    ‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: "{keyword}"
    ‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤:
    {places_info}

    ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ ‡πÇ‡∏î‡∏¢‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡πà‡∏≤‡∏™‡∏ô‡πÉ‡∏à, ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á, ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà, ‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á ‡∏°‡∏µ‡∏ó‡∏µ‡πà‡∏à‡∏≠‡∏î‡∏£‡∏ñ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡πà‡∏≤‡∏ß, ‡∏£‡∏™‡∏ä‡∏≤‡∏ï‡∏¥‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏≠‡∏£‡πà‡∏≠‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡πà‡∏≤‡∏ß, ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡πÄ‡∏î‡πá‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡∏™‡∏π‡∏á‡∏≠‡∏≤‡∏¢‡∏∏‡∏°‡∏±‡πâ‡∏¢.
    ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏ß‡πà‡∏≤‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÉ‡∏î.
    """

    try:
        # Send the prompt to LLM for recommendation
        response = llm.invoke(prompt)
        return response.content.strip()
    except Exception as e:
        print(f"Error generating recommendation: {e}")
        return "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥."

   
def explain_route_with_llm(route_data):
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô None ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    if not route_data or 'data' not in route_data or not route_data['data']:
        return "‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á"

    first_route = route_data['data'][0]
    if 'guide' not in first_route or not first_route['guide']:
        return "‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á"

    route_steps = []
    for instruction in first_route['guide']:
        turn = instruction.get('turn', '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏')
        name = instruction.get('name', '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏')
        distance = instruction.get('distance', '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏')
        interval = instruction.get('interval', '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏')
        step = f"üîπ ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ó‡∏µ‡πà {turn} ‡πÑ‡∏õ‡∏ó‡∏µ‡πà {name}, ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á {distance} ‡πÄ‡∏°‡∏ï‡∏£, ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á {interval} ‡πÄ‡∏°‡∏ï‡∏£"
        route_steps.append(step)

    route_description = "\n".join(route_steps)

    # print(f"‚úÖ Route description generated:\n{route_description}")  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡πÉ‡∏´‡πâ LLM

    prompt = f"""
    ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á:
    {route_description}

    ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏Ñ‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
    """

    try:
        if hasattr(llm, 'invoke'):
            response = llm.invoke(prompt)
            return response.content.strip()
        else:
            return "‚ùå LLM ‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô"
    except Exception as e:
        print(f"‚ùå Error generating description: {e}")
        return "‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á"

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
def display_route_explanation(route_data):
    explanation = explain_route_with_llm(route_data)
  

# #### ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡πÉ‡∏ô main ‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ ######
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ API
# places_interest = "‡∏≠‡∏¢‡∏≤‡∏Å‡∏Å‡∏¥‡∏ô‡∏Ç‡πâ‡∏≤‡∏ß"
# user_location = (13.7563, 100.5018)  # ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û‡∏Ø
# user_destination = (14.022788, 99.978337)  # ‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î ‡∏Å‡∏≤‡∏ç‡∏à‡∏ô‡∏ö‡∏∏‡∏£‡∏µ
# radius = 5  # ‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà 5 ‡∏Å‡∏¥‡πÇ‡∏•‡πÄ‡∏°‡∏ï‡∏£

# keyword = process_places_of_interest_routes(places_interest)  # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏¢‡∏Å keyword ‡∏à‡∏≤‡∏Å query
# if keyword:
#     print(f"Extracted Keyword: {keyword}")

#     route_points = [
#             (float(places_of_interest['latitude']), float(places_of_interest['longitude']))
#             for route in search_places_of_interest
#         ]

#         # Sort the points based on their proximity to each other starting from the user's location
#     sorted_route_points = sort_points(route_points, user_location)


# # ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡πà‡∏≤‡∏™‡∏ô‡πÉ‡∏à
# flon, flat, tlon, tlat = convert_locations(user_location, user_destination)  # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î

# print("\n--- Searching places along the route ---")
# route_data, places_of_interest = get_places_from_route(flon, flat, tlon, tlat, keyword, radius)
# if places_of_interest:
#     analyzed_places = extract_and_analyze_data(places_of_interest)
# else:
#     print("No places of interest found.")
# # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
# create_map(route_data, places_of_interest, user_location, user_destination, sorted_route_points)


# print("\n--- LLM Recommendations ---")
# recommendations = recommend_places(places_of_interest, keyword, top_n=10)
# print(recommendations)

# explanation = explain_route_with_llm(route_data)  
# # ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
# display_route_explanation(explanation)
